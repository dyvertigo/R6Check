

param(
    [Parameter(Mandatory=$false, HelpMessage="Discord webhook URL for report uploads")]
    [string]$WebhookUrl = "",
    
    [Parameter(Mandatory=$false, HelpMessage="Encoded webhook hash for secure transmission")]
    [string]$WebhookHash = ""
)

if ($WebhookHash -and -not $WebhookUrl) {
    try {
        $decoded = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($WebhookHash))
        $WebhookUrl = $decoded
        Write-Host "[+] Webhook decoded successfully" -ForegroundColor Green
    } catch {
        Write-Host "[-] Failed to decode webhook hash" -ForegroundColor Red
    }
}

$script:DiscordWebhookUrl = $WebhookUrl

function Write-UnifiedHtmlReport {
    param(
        [string]$OutputPath
    )
    if (-not $OutputPath) { $OutputPath = Join-Path ([System.Environment]::GetFolderPath('Desktop')) 'SystemCheckReport.html' }
    Write-Host "[>] Building unified HTML report: $OutputPath" -ForegroundColor Cyan

    $sections = $global:Sections

    $htmlHeader = @"
<html>
<head>
<meta charset='UTF-8'>
<title>System Check Report</title>
<style>
body { font-family: Segoe UI, Arial, sans-serif; background: #f6f7fb; color: #1f2937; margin: 0; }
header { background: #1f2937; color: #fff; padding: 16px 24px; }
main { padding: 16px 24px; }
.toc { background: #fff; border-radius: 8px; padding: 12px 16px; box-shadow: 0 1px 4px #0002; }
.toc a { margin-right: 12px; color: #2563eb; text-decoration: none; }
.grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 16px; }
.card { background: #fff; border-radius: 10px; box-shadow: 0 2px 8px #0002; overflow: hidden; }
.card h2 { margin: 0; padding: 12px 16px; background: #f3f4f6; border-bottom: 1px solid #e5e7eb; font-size: 18px; }
.card .content { padding: 12px 16px; }
.pill { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; margin-left: 8px; }
.pill.ok { background: #e6f4ea; color: #137333; }
.pill.warn { background: #fff4e5; color: #92400e; }
.pill.bad { background: #fde7e9; color: #a50e0e; }
pre { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; padding: 8px; white-space: pre-wrap; }
.line.bad { border-left: 4px solid #ef4444; padding-left: 8px; }
.line.warn { border-left: 4px solid #f59e0b; padding-left: 8px; }
.muted { color: #6b7280; }
footer { text-align: center; color: #6b7280; padding: 16px; }
table.summary { width: 100%; border-collapse: collapse; }
table.summary th, table.summary td { border-bottom: 1px solid #e5e7eb; padding: 8px; text-align: left; }
table.summary th { background: #f3f4f6; }
table.summary a { color: #2563eb; text-decoration: none; }
</style>
</head>
<body>
<header>
  <h1>System Check Report</h1>
  <div class='muted'>Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') | Generated by R6Check</div>
</header>
<main>
        <div class='toc'>
            <b>Jump to:</b>
            $(($sections | ForEach-Object { "<a href='#$([System.Net.WebUtility]::HtmlEncode(($_.Title -replace "[^A-Za-z0-9]","-")))'>$( [System.Net.WebUtility]::HtmlEncode($_.Title) )</a>" }) -join ' ')
        </div>
    <div class='grid'>
"@

        $summaryRows = ''
        foreach ($sec in $sections) {
                $sid = ($sec.Title -replace '[^A-Za-z0-9]','-')
                $titleHtml = [System.Net.WebUtility]::HtmlEncode($sec.Title)
                $summaryRows += "<tr><td><a href='#$sid'>$titleHtml</a></td><td>$($sec.Alerts)</td><td>$($sec.Notes)</td><td>$($sec.Items.Count)</td></tr>"
        }
        $cards = "<div class='card'><h2>Section Summary</h2><div class='content'><table class='summary'><thead><tr><th>Section</th><th>Alerts</th><th>Notes</th><th>Items</th></tr></thead><tbody>$summaryRows</tbody></table></div></div>"
    foreach ($sec in $sections) {
        $arr = $sec.Items
        $name = $sec.Title
        $counts = @{ bad = $sec.Alerts; warn = $sec.Notes }
        $pill = if ($counts.bad -gt 0) { "<span class='pill bad'>$($counts.bad) alerts</span>" } elseif ($counts.warn -gt 0) { "<span class='pill warn'>$($counts.warn) notes</span>" } else { "<span class='pill ok'>OK</span>" }
        $safeId = ($name -replace '[^A-Za-z0-9]','-')
        $cards += "<div class='card' id='$safeId'><h2>$( [System.Net.WebUtility]::HtmlEncode($name) ) $pill</h2><div class='content'>"
        foreach ($raw in $arr) {

            $lines = $raw -split "`r?`n"
            foreach ($l in $lines) {
                $cls = if ($l -match '\[!\]') { 'bad' } elseif ($l -match '\[\*\]') { 'warn' } else { '' }
                $esc = [System.Net.WebUtility]::HtmlEncode($l)
                $cards += "<div class='line $cls'><pre>$esc</pre></div>"
            }
        }
        $cards += "</div></div>"
    }

    $htmlFooter = @"
  </div>
</main>
<footer>
  Single-file report generated by R6Check.
</footer>
</body></html>
"@

    $htmlOut = $htmlHeader + $cards + $htmlFooter
    try {
        Set-Content -Path $OutputPath -Value $htmlOut -Encoding UTF8
        Write-Host "[+] Unified HTML report created at $OutputPath" -ForegroundColor Green
    } catch {
        Write-Host "[-] Failed to write unified HTML report: $_" -ForegroundColor Red
    }
    return $OutputPath
}
function Find-DMASpoofedDevices {
    Write-Host "[>] Detecting spoofed device names or IDs for DMA hardware..."
    try {
        $spoofedDevices = @()
        $devices = Get-CimInstance -ClassName Win32_PnPEntity
        foreach ($dev in $devices) {

            if ($dev.Name -match 'Generic|Unknown|USB Device|PCI Device' -or $dev.DeviceID -match 'FTDI|BusPirate|OpenOCD|DMA|PCIe|JTAG|SPI|kmBoxNet|fuser|leechcore|pcileech|screamer') {
                $global:LogEntries += "[!] Possible spoofed device detected: $($dev.Name) (DeviceID: $($dev.DeviceID))"; Write-Host "[!] Possible spoofed device detected: $($dev.Name) (DeviceID: $($dev.DeviceID))" -ForegroundColor Red
                $spoofedDevices += $dev.Name
            }
        }
        if ($spoofedDevices.Count -eq 0) {
            $global:LogEntries += "[+] No spoofed device names/IDs detected."; Write-Host "[+] No spoofed device names/IDs detected."
        }
    } catch {
        $errMsg = "Error detecting spoofed device names/IDs: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}
function Find-DMAFirmwareTools {
    Write-Host "[>] Searching for firmware flashing tools commonly used for DMA hardware..."
    try {
        $toolNames = @('kmBoxNetFlasher', 'fuserFlasher', 'PCILeechFlasher', 'ScreamerFlasher', 'flashrom', 'ftdi', 'jtag', 'spi', 'usbprog', 'buspirate', 'openocd', 'DMAFlasher', 'PCIeFlasher', 'firmwaretool', 'firmwareupdater')
        $foundTools = @()
        $searchPaths = @('C:\Program Files', 'C:\Program Files (x86)', "$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop")
        foreach ($path in $searchPaths) {
            Write-Host "[~] Scanning directory: $path" -ForegroundColor Cyan
            $fileCount = 0
            foreach ($tool in $toolNames) {
                $files = Get-ChildItem -Path $path -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $tool -and ($_.Extension -eq '.exe' -or $_.Extension -eq '.bat' -or $_.Extension -eq '.ps1') }
                $fileCount += $files.Count
                foreach ($file in $files) {
                    $global:LogEntries += "[!] Firmware flashing tool found: $($file.FullName)"; Write-Host "[!] Firmware flashing tool found: $($file.FullName)" -ForegroundColor Red
                    $foundTools += $file.FullName
                }
            }
            Write-Host "[~] Scanned $fileCount files in $path" -ForegroundColor DarkGray
        }
        if ($foundTools.Count -eq 0) {
            $global:LogEntries += "[+] No firmware flashing tools detected."; Write-Host "[+] No firmware flashing tools detected."
        }
    } catch {
        $errMsg = "Error searching for firmware flashing tools: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}
function Find-DMADevices {
    Write-Host "[>] Scanning for suspicious PCIe/USB devices (kmBoxNet, fuser, PCILeech, Screamer, etc.)..."
    try {
        $deviceKeywords = @('kmBoxNet', 'fuser', 'leechcore', 'pcileech', 'screamer', 'dma', 'pci_dma', 'pci_fuser', 'pci_kmbox')
        $foundDevices = @()

        $devices = Get-CimInstance -ClassName Win32_PnPEntity | Where-Object {
            foreach ($k in $deviceKeywords) { if ($k -and ($_.Name -match $k -or $_.DeviceID -match $k)) { return $true } }
            return $false
        }
        if ($devices) {
            $global:LogEntries += "[!] Suspicious DMA PCIe/USB devices detected:"; Write-Host "[!] Suspicious DMA PCIe/USB devices detected:" -ForegroundColor Red
            foreach ($dev in $devices) {
                $global:LogEntries += (" - {0} (DeviceID: {1})" -f $dev.Name, $dev.DeviceID); Write-Host (" - {0} (DeviceID: {1})" -f $dev.Name, $dev.DeviceID) -ForegroundColor Yellow
                $foundDevices += $dev.Name
            }
        } else {
            $global:LogEntries += "[+] No suspicious DMA PCIe/USB devices detected."; Write-Host "[+] No suspicious DMA PCIe/USB devices detected."
        }
    } catch {
        $errMsg = "Error scanning DMA PCIe/USB devices: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}
function Find-DMAServices {
    Write-Host "[>] Checking for suspicious services (kmBoxNet, fuser, PCILeech, Screamer, etc.)..."
    try {
        $serviceNames = @('kmBoxNet', 'fuser', 'leechcore', 'pcileech', 'screamer', 'dma', 'pci_dma', 'pci_fuser', 'pci_kmbox')
        $foundServices = @()
        $services = Get-Service | Where-Object {
            foreach ($k in $serviceNames) { if ($k -and ($_.Name -match $k -or $_.DisplayName -match $k)) { return $true } }
            return $false
        }
        if ($services) {
            $global:LogEntries += "[!] Suspicious DMA services detected:"; Write-Host "[!] Suspicious DMA services detected:" -ForegroundColor Red
            foreach ($svc in $services) {
                $global:LogEntries += (" - {0} ({1})" -f $svc.Name, $svc.DisplayName); Write-Host (" - {0} ({1})" -f $svc.Name, $svc.DisplayName) -ForegroundColor Yellow
                $foundServices += $svc.Name
            }
        } else {
            $global:LogEntries += "[+] No suspicious DMA services detected."; Write-Host "[+] No suspicious DMA services detected."
        }
    } catch {
        $errMsg = "Error checking DMA services: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}
function Find-DMAProcesses {
    Write-Host "[>] Checking for suspicious running processes (kmBoxNet, fuser, PCILeech, Screamer, etc.)..."
    try {
        $processNames = @('kmBoxNet', 'fuser', ('leechcore', 'pcileech', 'screamer', 'dma', 'pci_dma', 'pci_fuser', 'pci_kmbox'))
        $foundProcesses = @()
        $procs = Get-Process | Where-Object {
            foreach ($k in $processNames) { if ($k -and ($_.Name -match $k)) { return $true } }
            return $false
        }
        if ($procs) {
            $global:LogEntries += "[!] Suspicious DMA processes detected:"; Write-Host "[!] Suspicious DMA processes detected:" -ForegroundColor Red
            foreach ($proc in $procs) {
                $global:LogEntries += (" - {0} (PID: {1})" -f $proc.Name, $proc.Id); Write-Host (" - {0} (PID: {1})" -f $proc.Name, $proc.Id) -ForegroundColor Yellow
                $foundProcesses += $proc.Name
            }
        } else {
            $global:LogEntries += "[+] No suspicious DMA processes detected."; Write-Host "[+] No suspicious DMA processes detected."
        }
    } catch {
        $errMsg = "Error checking DMA processes: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}
function Find-DMADriversAndServices {
    Write-Host "[>] Checking for suspicious DMA drivers/services (kmBoxNet, fuser, PCILeech, Screamer, etc.)..."
    try {
        $driverNames = @('kmBoxNet', 'fuser', 'leechcore', 'pcileech', 'screamer', 'dma', 'pci_dma', 'pci_fuser', 'pci_kmbox')
        $driverFiles = @('kmBoxNet.sys', 'fuser.sys', 'leechcore.sys', 'pcileech.sys', 'screamer.sys')
        $foundDrivers = @()
        $foundServices = @()

        $drivers = Get-CimInstance -ClassName Win32_SystemDriver | Where-Object {
            foreach ($k in $driverNames) { if ($k -and ($_.Name -match $k -or $_.DisplayName -match $k)) { return $true } }
            return $false
        }
        if ($drivers) {
            $global:LogEntries += "[!] Suspicious DMA drivers detected:"; Write-Host "[!] Suspicious DMA drivers detected:" -ForegroundColor Red
            foreach ($drv in $drivers) {
                $global:LogEntries += (" - {0} ({1})" -f $drv.Name, $drv.DisplayName); Write-Host (" - {0} ({1})" -f $drv.Name, $drv.DisplayName) -ForegroundColor Yellow
                $foundDrivers += $drv.Name
            }
        } else {
            $global:LogEntries += "[+] No suspicious DMA drivers detected."; Write-Host "[+] No suspicious DMA drivers detected."
        }

        foreach ($file in $driverFiles) {
            $sysPath = "C:\Windows\System32\drivers\$file"
            if (Test-Path $sysPath) {
                $global:LogEntries += "[!] DMA driver file found: $sysPath"; Write-Host "[!] DMA driver file found: $sysPath" -ForegroundColor Red
                $foundDrivers += $file
            }
        }

        $regPath = "HKLM:\SYSTEM\CurrentControlSet\Services"
        foreach ($name in $driverNames) {
            $svcPath = Join-Path $regPath $name
            if (Test-Path $svcPath) {
                $global:LogEntries += "[!] DMA service registry key found: $svcPath"; Write-Host "[!] DMA service registry key found: $svcPath" -ForegroundColor Red
                $foundServices += $name
            }
        }
        if ($foundDrivers.Count -eq 0 -and $foundServices.Count -eq 0) {
            $global:LogEntries += "[+] No suspicious DMA services found."; Write-Host "[+] No suspicious DMA services found."
        }
    } catch {
        $errMsg = "Error checking DMA drivers/services: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}

if (-not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Write-Host "[>] Relaunching in a new PowerShell window with administrator rights..." -ForegroundColor Cyan
    $adminShell = if (Get-Command -Name pwsh.exe -ErrorAction SilentlyContinue) { 'pwsh.exe' } else { 'powershell.exe' }
    

    $paramString = ""
    if ($WebhookUrl) {
        $paramString += " -WebhookUrl `"$WebhookUrl`""
    }
    if ($WebhookHash) {
        $paramString += " -WebhookHash `"$WebhookHash`""
    }
    
    $arguments = "-NoProfile -ExecutionPolicy Bypass -File `"$PSCommandPath`"$paramString"
    Start-Process $adminShell $arguments -Verb RunAs
    exit 0
}

if (-not $global:LogEntries) { $global:LogEntries = @() }

if (-not $global:Sections) { $global:Sections = @() }

function Invoke-Section {
    param(
        [Parameter(Mandatory=$true)][string]$Title,
        [Parameter(Mandatory=$true)][scriptblock]$Action
    )
    Write-Host "=== $Title ===" -ForegroundColor Cyan
    $startIndex = $global:LogEntries.Count
    $global:LogEntries += "[#] BEGIN: $Title"
    try {
        & $Action
    } catch {
        $global:LogEntries += "[-] ${Title}: $($_)"
        Write-Host "[-] ${Title}: $($_)" -ForegroundColor Red
    }
    $endIndex = $global:LogEntries.Count
    $items = @()
    if ($endIndex -gt $startIndex) {
        $sliceStart = [Math]::Min($startIndex + 1, $global:LogEntries.Count)
        $sliceEnd = $global:LogEntries.Count - 1
        if ($sliceEnd -ge $sliceStart) {
            $items = $global:LogEntries[$sliceStart..$sliceEnd]
        }
    }
    $alerts = ($items | Where-Object { $_ -match '\[!\]' }).Count
    $notes = ($items | Where-Object { $_ -match '\[\*\]' }).Count
    $global:Sections += [PSCustomObject]@{ Title=$Title; Items=$items; Alerts=$alerts; Notes=$notes }
    $global:LogEntries += "[#] END: $Title"
}

 

function Test-AdministratorPrivileges {
    Write-Host "[>] Checking administrator privileges..."
    try {
        $currentIdentity = [Security.Principal.WindowsIdentity]::GetCurrent()
        $principal = New-Object Security.Principal.WindowsPrincipal($currentIdentity)
        if (-not $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
            $global:LogEntries += "[-] Administrator privileges are required."
            Write-Host "[-] Administrator privileges are required."
            exit
        } else {
            $global:LogEntries += "[+] Administrator privileges confirmed."
            Write-Host "[+] Administrator privileges confirmed."
        }
    } catch {
        $global:LogEntries += "[-] Error checking administrator privileges: $_"
        Write-Host "[-] Error checking administrator privileges: $_"
        exit
    }
}

function Get-SecureBootStatus {
    Write-Host "[>] Checking Secure Boot status..."
    try {
        if (Get-Command Confirm-SecureBootUEFI -ErrorAction SilentlyContinue) {
            $secureBootState = Confirm-SecureBootUEFI
            if ($secureBootState) {
                $global:LogEntries += "[+] Secure Boot is ON."
                Write-Host "[+] Secure Boot is ON."
            } else {
                $global:LogEntries += "[-] Secure Boot is OFF."
                Write-Host "[-] Secure Boot is OFF."
            }
        } else {
            $global:LogEntries += "[-] Secure Boot not available on this system."
            Write-Host "[-] Secure Boot not available on this system."
        }
    } catch {
        $global:LogEntries += "[-] Unable to retrieve Secure Boot status: $_"
        Write-Host "[-] Unable to retrieve Secure Boot status: $_"
    }
}

function Get-OneDrivePath {
    Write-Host "[>] Checking OneDrive path..."
    try {
        $envOneDrive = [System.IO.Path]::Combine($env:UserProfile, "OneDrive")
        if (Test-Path $envOneDrive) {
            $global:LogEntries += "[+] OneDrive path detected: $envOneDrive"
            Write-Host "[+] OneDrive path detected: $envOneDrive"
            return $envOneDrive
        } else {
            $global:LogEntries += "[-] OneDrive path not found."
            Write-Host "[-] OneDrive path not found."
            return $null
        }
    } catch {
        $global:LogEntries += "[-] Error finding OneDrive path: $_"
        Write-Host "[-] Error finding OneDrive path: $_"
        return $null
    }
}

function Get-WindowsInstallDate {
    Write-Host "[>] Checking Windows installation date..."
    try {
    $os = Get-CimInstance -ClassName Win32_OperatingSystem
    $installDate = try { [Management.ManagementDateTimeConverter]::ToDateTime($os.InstallDate) } catch { $null }
        $global:LogEntries += "[+] Windows Installation Date: $installDate"
        Write-Host "[+] Windows Installation Date: $installDate"
    } catch {
        $global:LogEntries += "[-] Unable to retrieve Windows installation date: $_"
        Write-Host "[-] Unable to retrieve Windows installation date: $_"
    }
}

function Find-SuspiciousFiles {
    Write-Host "[>] Searching for suspicious files..."
    try {
        $global:LogEntries += "[*] Searching for suspicious files with 'loader' in the name..."
        $searchPaths = @($env:UserProfile, "$env:UserProfile\Downloads")
        $excludeDirs = @('AppData', 'Windows', 'Program Files', 'Program Files (x86)', 'node_modules', 'System Volume Information')
        $maxDepth = 3
        $susFiles = @()
        function Get-SafeChildItems {
            param($Path, $Depth)
            if ($Depth -le 0) { return }
            try {
                $items = Get-ChildItem -Path $Path -File -Include *.exe,*.zip,*.rar -ErrorAction SilentlyContinue
                $susFiles += $items | Where-Object { $_.Name -match "loader" }
                $dirs = Get-ChildItem -Path $Path -Directory -ErrorAction SilentlyContinue | Where-Object { $excludeDirs -notcontains $_.Name }
                foreach ($dir in $dirs) {
                    Get-SafeChildItems -Path $dir.FullName -Depth ($Depth-1)
                }
            } catch {}
        }
        foreach ($path in $searchPaths) {
            if (Test-Path $path) {
                Get-SafeChildItems -Path $path -Depth $maxDepth
            }
        }
        if ($susFiles.Count -gt 0) {
            $global:LogEntries += "[!] Suspicious files found:"
            Write-Host "[!] Suspicious files found:"
            foreach ($file in $susFiles) {
                $global:LogEntries += $file.FullName
                Write-Host $file.FullName
            }
        } else {
            $global:LogEntries += "[+] No suspicious files found."
            Write-Host "[+] No suspicious files found."
        }
    } catch {
        $errMsg = "Error finding suspicious files: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}
function Get-SecurityToolIndicators {
    param([string]$ProgramPath)

    $securityTools = @(
        'mimikatz', 'psexec', 'procdump', 'rubeus', 'bloodhound', 'sharphound',
        'netcat', 'nc\.exe', 'nmap', 'wireshark', 'hashcat', 'john',
        'lazagne', 'pwdump', 'wceservice', 'responder', 'hydra',
        'processhacker', 'xenos', 'extremeinjector'
    )
    foreach ($tool in $securityTools) {
        if ($ProgramPath -match $tool) { return $true }
    }
    return $false
}

function Get-SuspiciousPathIndicators {
    param([string]$Path)

    $indicators = @()
    if ($Path -match "\\Temp\\") { $indicators += "Temp Directory" }
    if ($Path -match "\\Downloads\\") { $indicators += "Downloads Directory" }
    if ($Path -match "\\AppData\\Local\\Temp") { $indicators += "AppData Temp" }
    if ($Path -match "\\Public\\") { $indicators += "Public Directory" }
    if ($Path -match "\\Recycle") { $indicators += "Recycle Bin" }
    if ($Path -match "\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup") { $indicators += "Startup Folder" }
    if ($Path -match "^\\\\") { $indicators += "Network Path" }
    return $indicators
}

function Get-BAMStateUserSettings {
    Write-Host "[>] Checking BAM State User Settings (PowerShell-Hunter Enhanced)..."
    try {
        $registryPath = "HKLM:\SYSTEM\CurrentControlSet\Services\bam\State\UserSettings"
        if (Test-Path $registryPath) {
            $userSettings = Get-ChildItem -Path $registryPath
            if ($userSettings) {
                $global:LogEntries += "[*] BAM State User Settings Analysis:"
                Write-Host "[*] BAM State User Settings Analysis:"
                
                $suspiciousEntries = @()
                foreach ($userKey in $userSettings) {
                    try {
                            $bamEntries = Get-ItemProperty -Path $userKey.PSPath -ErrorAction SilentlyContinue
                        if ($bamEntries) {
                            $bamEntries.PSObject.Properties | Where-Object { $_.Name -notmatch 'PS' } | ForEach-Object {
                                    $exePath = $_.Name
                                

                                    $isSecurityTool = Get-SecurityToolIndicators -ProgramPath $exePath
                                    $suspiciousPath = Get-SuspiciousPathIndicators -Path $exePath
                                
                                    if ($isSecurityTool -or $suspiciousPath.Count -gt 0) {
                                        $indicators = @()
                                        if ($isSecurityTool) { $indicators += "Security Tool" }
                                        if ($suspiciousPath) { $indicators += $suspiciousPath }
                                    
                                        $suspiciousEntries += "[!] $exePath - Indicators: $($indicators -join ', ')"
                                    }
                            }
                        }
                    } catch {}
                }
                
                if ($suspiciousEntries.Count -gt 0) {
                    $global:LogEntries += "[!] Suspicious BAM Entries Detected:"
                    Write-Host "[!] Suspicious BAM Entries Detected:" -ForegroundColor Red
                    $suspiciousEntries | ForEach-Object { 
                        $global:LogEntries += $_
                        Write-Host $_ -ForegroundColor Yellow
                    }
                } else {
                    $global:LogEntries += "[+] No suspicious BAM entries detected."
                    Write-Host "[+] No suspicious BAM entries detected."
                }
            } else {
                $global:LogEntries += "[+] No User Settings entries found."
                Write-Host "[+] No User Settings entries found."
            }
        } else {
            $global:LogEntries += "[+] BAM State User Settings registry path not found."
            Write-Host "[+] BAM State User Settings registry path not found."
        }
    } catch {
        $errMsg = "Error accessing BAM State User Settings: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}

function Get-PrefetchFiles {
    Write-Host "[>] Checking Prefetch files (PowerShell-Hunter Enhanced)..."
    try {
        $prefetchPath = "C:\Windows\Prefetch"
        if (Test-Path $prefetchPath) {
            $pfFiles = Get-ChildItem -Path $prefetchPath -Filter *.pf -File -ErrorAction SilentlyContinue
            if ($pfFiles.Count -gt 0) {
                $global:LogEntries += "[*] Prefetch files analysis (total: $($pfFiles.Count)):"
                Write-Host "[*] Prefetch files analysis (total: $($pfFiles.Count)):"
                

                $suspiciousPrefetch = @()
                $recentFiles = $pfFiles | Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-7) }
                
                foreach ($pf in $recentFiles) {
                    $programName = $pf.Name -replace '\.pf$', ''
                        $isSecurityTool = Get-SecurityToolIndicators -ProgramPath $programName
                    

                        $hour = $pf.LastWriteTime.Hour
                        $isOffHours = ($hour -ge 22 -or $hour -le 5)
                    
                        if ($isSecurityTool -or $isOffHours) {
                            $indicators = @()
                            if ($isSecurityTool) { $indicators += "Security Tool" }
                            if ($isOffHours) { $indicators += "Off-Hours ($($pf.LastWriteTime.ToString('HH:mm')))" }
                        
                            $suspiciousPrefetch += "[!] $programName - Last: $($pf.LastWriteTime) - Indicators: $($indicators -join ', ')"
                        }
                }
                
                if ($suspiciousPrefetch.Count -gt 0) {
                    $global:LogEntries += "[!] Suspicious Prefetch entries detected:"
                    Write-Host "[!] Suspicious Prefetch entries detected:" -ForegroundColor Red
                    $suspiciousPrefetch | ForEach-Object {
                        $global:LogEntries += $_
                        Write-Host $_ -ForegroundColor Yellow
                    }
                } else {
                    $global:LogEntries += "[+] No suspicious Prefetch patterns detected."
                    Write-Host "[+] No suspicious Prefetch patterns detected."
                }
            } else {
                $global:LogEntries += "[+] No Prefetch files found."
                Write-Host "[+] No Prefetch files found."
            }
        } else {
            $global:LogEntries += "[+] Prefetch folder not found."
            Write-Host "[+] Prefetch folder not found."
        }
    } catch {
        $errMsg = "Error logging Prefetch files: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}

function Get-RainbowSixUsernames {
    Write-Host "[>] Checking Rainbow Six Siege usernames..."
    try {
        $userName = $env:UserName
        $oneDrivePath = Get-OneDrivePath
        $potentialPaths = @("C:\Users\$userName\Documents\My Games\Rainbow Six - Siege")
        if ($oneDrivePath) {
            $potentialPaths += "$oneDrivePath\Documents\My Games\Rainbow Six - Siege"
        }
        $allUserNames = @()
        foreach ($path in $potentialPaths) {
            if (Test-Path -Path $path) {
                $dirNames = Get-ChildItem -Path $path -Directory | ForEach-Object { $_.Name }
                $allUserNames += $dirNames
            }
        }
        $uniqueUserNames = $allUserNames | Select-Object -Unique
        if ($uniqueUserNames.Count -eq 0) {
            $global:LogEntries += "[+] No Rainbow Six Siege usernames detected."
            Write-Host "[+] No Rainbow Six Siege usernames detected."
        } else {
            $global:LogEntries += "[*] Rainbow Six Siege Usernames Detected:"
            Write-Host "[*] Rainbow Six Siege Usernames Detected:"
            $uniqueUserNames | ForEach-Object { $global:LogEntries += " - $_"; Write-Host " - $_" }
            $global:LogEntries += "[*] Rainbow Six Siege Stats URLs:"
            Write-Host "[*] Rainbow Six Siege Stats URLs:"
            foreach ($name in $uniqueUserNames) {
                $url = "https://stats.cc/siege/$name"
                $global:LogEntries += " - $url"
                Write-Host " - $url"
            }
        }
    } catch {
        $errMsg = "Error retrieving Rainbow Six Siege usernames: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}

function Get-SuspiciousProcesses {
    Write-Host "[>] Checking for suspicious processes (PowerShell-Hunter Enhanced)..."
    $cheatPattern = 'cheat|injector|loader|aimbot|esp|r6hack|r6cheat|r6s|r6s_cheat|r6s_hack|r6s_loader|r6s_injector|r6s_bypass|r6s_spoofer|spoofer|ring0|kernel|xenos|extremeinjector|processhacker|r6s_crack|r6smod|modmenu'
    $found = @()
    $procs = Get-Process | Select-Object Name,Id,Path
    
    foreach ($proc in $procs) {
        $procName = $proc.Name
        $procPath = $proc.Path
        

        if ($procName -match $cheatPattern -or ($procPath -and $procPath -match $cheatPattern)) {
            $found += $proc
        }

        elseif ($procPath -and (Get-SecurityToolIndicators -ProgramPath $procPath)) {
            $found += $proc | Add-Member -NotePropertyName 'DetectionReason' -NotePropertyValue 'Security Tool' -PassThru -Force
        }

        elseif ($procPath) {
            $suspiciousPaths = Get-SuspiciousPathIndicators -Path $procPath
            if ($suspiciousPaths.Count -gt 0) {
                $found += $proc | Add-Member -NotePropertyName 'DetectionReason' -NotePropertyValue ($suspiciousPaths -join ', ') -PassThru -Force
            }
        }
    }
    
    if ($found.Count -gt 0) {
        $global:LogEntries += "[!] Suspicious processes detected:"
        Write-Host "[!] Suspicious processes detected:" -ForegroundColor Red
        $found | ForEach-Object { 
            $reason = if ($_.DetectionReason) { " - Reason: $($_.DetectionReason)" } else { "" }
            $msg = " - {0} (PID: {1}){2}" -f $_.Name, $_.Id, $reason
            $global:LogEntries += $msg
            Write-Host $msg -ForegroundColor Yellow
        }
    } else {
        $global:LogEntries += "[+] No suspicious processes detected."
        Write-Host "[+] No suspicious processes detected."
    }
}

function Get-SuspiciousNetworkConnections {
    Write-Host "[>] Checking for suspicious network connections (Enhanced Analysis)..."
    try {

        $portDescriptions = @{
            '80' = 'HTTP - Common for C2 servers, cheat license validation'
            '443' = 'HTTPS - Common for C2 servers, encrypted cheat communications'
            '8080' = 'HTTP Proxy - Often used by cheats for API calls'
            '1337' = 'LEET Port - Popular among cheat developers'
            '6666' = 'IRC/Malware - Often used by botnets and cheats'
            '6969' = 'Common cheat communication port'
            '12345' = 'NetBus/Backdoor - Known trojan port'
            '31337' = 'Elite/Hacker Port - Common in underground software'
            '27015' = 'Source Engine Game Port'
            '27016' = 'Source Engine RCON'
            '27017' = 'MongoDB - Sometimes used for cheat databases'
            '3074' = 'Xbox Live - Could indicate console emulation cheats'
            '5000' = 'UPnP - Sometimes abused by cheats'
            '5555' = 'Android Debug Bridge - Could indicate mobile cheat injection'
            '7777' = 'Unreal Engine - Game server or cheat server'
            '9999' = 'Common cheat server port'
        }

        $connections = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | 
            Where-Object { $_.RemoteAddress -ne '127.0.0.1' -and $_.RemoteAddress -ne '::1' }

        $suspiciousConnections = @()
        
        foreach ($conn in $connections) {
            $remotePort = $conn.RemotePort.ToString()
            $localPort = $conn.LocalPort.ToString()
            

            if ($portDescriptions.ContainsKey($remotePort) -or $portDescriptions.ContainsKey($localPort)) {
                try {
                    $process = Get-Process -Id $conn.OwningProcess -ErrorAction SilentlyContinue
                    $processName = if ($process) { $process.ProcessName } else { "Unknown" }
                    $processPath = if ($process) { $process.Path } else { "N/A" }
                    

                    $remoteHost = try {
                        [System.Net.Dns]::GetHostEntry($conn.RemoteAddress).HostName
                    } catch {
                        $conn.RemoteAddress
                    }
                    

                    $portDesc = if ($portDescriptions.ContainsKey($remotePort)) {
                        $portDescriptions[$remotePort]
                    } else {
                        $portDescriptions[$localPort]
                    }
                    
                    $connInfo = [PSCustomObject]@{
                        ProcessName = $processName
                        PID = $conn.OwningProcess
                        ProcessPath = $processPath
                        LocalAddress = "$($conn.LocalAddress):$($conn.LocalPort)"
                        RemoteAddress = "$remoteHost`:$($conn.RemotePort)"
                        RemoteIP = $conn.RemoteAddress
                        State = $conn.State
                        PortDescription = $portDesc
                    }
                    
                    $suspiciousConnections += $connInfo
                } catch {
                    Write-Verbose "Error processing connection: $_"
                }
            }
        }

        if ($suspiciousConnections.Count -gt 0) {
            $global:LogEntries += "[!] Suspicious network connections detected ($($suspiciousConnections.Count) total):"
            Write-Host "[!] Suspicious network connections detected ($($suspiciousConnections.Count) total):" -ForegroundColor Red
            
                        foreach ($conn in $suspiciousConnections) {
                                $output = @"
    Process: $($conn.ProcessName) (PID: $($conn.PID))
    Path   : $($conn.ProcessPath)
    Local  : $($conn.LocalAddress)
    Remote : $($conn.RemoteAddress) (IP: $($conn.RemoteIP))
    State  : $($conn.State)
    Port   : $($conn.PortDescription)
"@
                                $global:LogEntries += $output
                                Write-Host $output -ForegroundColor Yellow
                        }
            

            $byProcess = $suspiciousConnections | Group-Object ProcessName
            $global:LogEntries += "`n[*] Summary by Process:"
            Write-Host "`n[*] Summary by Process:" -ForegroundColor Cyan
            foreach ($group in $byProcess) {
                $summary = "  - $($group.Name): $($group.Count) connection(s)"
                $global:LogEntries += $summary
                Write-Host $summary
            }
            
        } else {
            $global:LogEntries += "[+] No suspicious network connections detected."
            Write-Host "[+] No suspicious network connections detected."
        }
    } catch {
        $errMsg = "Error checking network connections: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}

function Get-RecentPrograms {
    Write-Host "[>] Listing recently installed programs..."
    try {
        $recent = Get-ItemProperty @(
            'HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*',
            'HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*'
        ) | Where-Object { $_.InstallDate -and $_.InstallDate -match '^\d{8}$' } | Sort-Object InstallDate -Descending | Select-Object -First 10 DisplayName, InstallDate
        if ($recent) {
            $global:LogEntries += "[*] Recently installed programs:"
            $recent | ForEach-Object { $global:LogEntries += (" - {0} (Installed: {1})" -f $_.DisplayName, $_.InstallDate); Write-Host (" - {0} (Installed: {1})" -f $_.DisplayName, $_.InstallDate) }
        } else {
            $global:LogEntries += "[+] No recent programs found."
            Write-Host "[+] No recent programs found."
        }
    } catch {
        $errMsg = "Error listing recent programs: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}

function Get-SuspiciousScheduledTasks {
    Write-Host "[>] Checking for suspicious scheduled tasks..."
    try {
        $tasks = Get-ScheduledTask -ErrorAction SilentlyContinue | Where-Object { $_.TaskName -match 'cheat|inject|loader|hack|r6s|spoofer|bypass' }
        if ($tasks -and $tasks.Count -gt 0) {
            $global:LogEntries += "[!] Suspicious scheduled tasks detected:"
            $tasks | ForEach-Object { $global:LogEntries += (" - {0}" -f $_.TaskName); Write-Host (" - {0}" -f $_.TaskName) }
        } else {
            $global:LogEntries += "[+] No suspicious scheduled tasks detected."
            Write-Host "[+] No suspicious scheduled tasks detected."
        }
    } catch {
        $errMsg = "Error checking scheduled tasks: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}

function Get-SuspiciousDrivers {
    Write-Host "[>] Checking for suspicious drivers..."
    try {
    $drivers = Get-CimInstance -ClassName Win32_SystemDriver | Where-Object { $_.Name -match 'cheat|hack|inject|spoofer|bypass|ring0|kernel' -or $_.DisplayName -match 'cheat|hack|inject|spoofer|bypass|ring0|kernel' }
        if ($drivers) {
            $global:LogEntries += "[!] Suspicious drivers detected:"
            $drivers | ForEach-Object { $global:LogEntries += (" - {0} ({1})" -f $_.Name, $_.DisplayName); Write-Host (" - {0} ({1})" -f $_.Name, $_.DisplayName) }
        } else {
            $global:LogEntries += "[+] No suspicious drivers detected."
            Write-Host "[+] No suspicious drivers detected."
        }
    } catch {
        $errMsg = "Error checking drivers: $_"
        $global:LogEntries += "[-] $errMsg"
        Write-Host "[-] $errMsg"
    }
}

function Send-DiscordMessage {
    param (
        [string]$Message
    )

    $discordWebhookUrl = if ($global:DiscordWebhookUrl -and $global:DiscordWebhookUrl -ne '') { $global:DiscordWebhookUrl } else { '' }
    if (-not $discordWebhookUrl) { Write-Host "[!] No Discord webhook configured; skipping message send."; return }
    $initiator = "System Check initiated by R6Check"
    
    $riskSummary = ''
    if ($global:LogEntries) {
        $summaryHeader = '================== SUMMARY =================='
        $startIndex = $global:LogEntries.IndexOf($summaryHeader)
        if ($startIndex -ge 0) {
            $riskSummary = ($global:LogEntries[$startIndex..($global:LogEntries.Count-1)] -join "`n")
        }
    }
    $jsonPayload = @{ content = "$initiator`n$Message`n`n$riskSummary" } | ConvertTo-Json
    try {
        Invoke-RestMethod -Uri $discordWebhookUrl -Method Post -ContentType "application/json" -Body $jsonPayload
    } catch {
        $errMsg = "Failed to send message to Discord webhook: $_"
        Write-Host "[-] $errMsg"
    }
}

function Send-DiscordLogFile {
    param(
        [string[]]$Files
    )

    $discordWebhookUrl = if ($global:DiscordWebhookUrl -and $global:DiscordWebhookUrl -ne '') { $global:DiscordWebhookUrl } else { '' }
    if (-not $discordWebhookUrl) { Write-Host "[!] No Discord webhook configured; skipping." ; return }

    if (-not $global:MaxAttachSizeMB -or $global:MaxAttachSizeMB -le 0) { $global:MaxAttachSizeMB = 8 }

    Write-Host "[>] Using Discord webhook: $($discordWebhookUrl -replace 'https://discord.com/api/webhooks/','WEBHOOK:')"

    if (-not $Files -or $Files.Count -eq 0) {
        $desktopPath = [System.Environment]::GetFolderPath('Desktop')
        $Files = @(
            Join-Path -Path $desktopPath -ChildPath "SystemCheckReport.html"
        )
    }

    Add-Type -AssemblyName System.Net.Http
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    $client = New-Object System.Net.Http.HttpClient
    $multipart = New-Object System.Net.Http.MultipartFormDataContent

    $payload = @{ content = "System Check Logs" } | ConvertTo-Json -Depth 4
    $payloadPart = New-Object System.Net.Http.StringContent($payload, [System.Text.Encoding]::UTF8, 'application/json')
    $multipart.Add($payloadPart, 'payload_json')

    $streams = @()
    try {
        $maxBytes = [int]($global:MaxAttachSizeMB * 1MB)
        $fileIndex = 0
        foreach ($file in $Files) {
            if (-not (Test-Path $file)) { Write-Host "[-] File not found: $file"; continue }
            $fi = Get-Item $file
            $useFile = $file

            if ($fi.Length -gt $maxBytes) {

                $zipPath = Join-Path $env:TEMP ([IO.Path]::GetFileNameWithoutExtension($file) + '_single.zip')
                if (Test-Path $zipPath) { Remove-Item $zipPath -Force -ErrorAction SilentlyContinue }
                $zip = [System.IO.Compression.ZipFile]::Open($zipPath, [System.IO.Compression.ZipArchiveMode]::Create)
                try {
                    $entry = $zip.CreateEntry([IO.Path]::GetFileName($file))
                    $entryStream = $entry.Open()
                    $origStream = [System.IO.File]::OpenRead($file)
                    try { $origStream.CopyTo($entryStream) } finally { $origStream.Close(); $entryStream.Close() }
                } finally { $zip.Dispose() }
                if ((Get-Item $zipPath).Length -gt $fi.Length) { Remove-Item $zipPath -Force } else { $useFile = $zipPath }
            }

            $sizeKB = [math]::Round((Get-Item $useFile).Length / 1KB, 2)
            Write-Host "[>] Attaching file: $useFile (size: $sizeKB KB)"

            $fs = [System.IO.File]::OpenRead($useFile)
            $streams += $fs
            $filePart = New-Object System.Net.Http.StreamContent($fs)

            $ctype = if ($useFile -match '\.html$') { 'text/html' } elseif ($useFile -match '\.zip$') { 'application/zip' } else { 'text/plain' }
            $filePart.Headers.ContentType = [System.Net.Http.Headers.MediaTypeHeaderValue]::Parse($ctype)

            $multipart.Add($filePart, "files[$fileIndex]", [System.IO.Path]::GetFileName($useFile))
            $fileIndex++
        }

        if ($multipart.Count -le 0) { Write-Host "[-] No files attached to send."; return }

        Write-Host "[>] Sending log file(s) to Discord webhook..."
        $response = $client.PostAsync($discordWebhookUrl, $multipart).Result

        if ($response.IsSuccessStatusCode) {
            Write-Host "[+] Files successfully sent to Discord webhook."
        } else {
            Write-Host ("[-] Failed to send files to Discord webhook. Status: {0} {1}" -f $response.StatusCode, $response.ReasonPhrase)
            $errorContent = $response.Content.ReadAsStringAsync().Result
            Write-Host ("[-] Discord response body: {0}" -f $errorContent)
        }
    } catch {
        $errMsg = "Exception sending log file(s) to Discord webhook: $_"
        Write-Host "[-] $errMsg"
    } finally {
        foreach ($s in $streams) { try { $s.Close(); $s.Dispose() } catch {} }
        try { $client.Dispose() } catch {}
    }
}

function Set-DiscordWebhook {
    param()
    try {

        if ($script:DiscordWebhookUrl -and $script:DiscordWebhookUrl.Trim()) {
            $global:DiscordWebhookUrl = $script:DiscordWebhookUrl.Trim()
            $masked = $global:DiscordWebhookUrl -replace 'https://discord.com/api/webhooks/','WEBHOOK:'
            Write-Host "[+] Using webhook from command-line parameter ($masked)" -ForegroundColor Green
        } else {
            Write-Host "[~] No Discord webhook configured (parameter not supplied)." -ForegroundColor DarkYellow
        }
    } catch {
        Write-Host "[-] Error loading Discord webhook: $_" -ForegroundColor Red
    }
}

function Invoke-SystemCheck {
    Write-Host "[>] Starting system check..."

    Invoke-Section -Title "Administrator Privileges" { Test-AdministratorPrivileges }
    Invoke-Section -Title "Secure Boot" { Get-SecureBootStatus }
    Invoke-Section -Title "Windows Install Date" { Get-WindowsInstallDate }
    Invoke-Section -Title "Rainbow Six Usernames" { Get-RainbowSixUsernames }
    Invoke-Section -Title "Suspicious Files" { Find-SuspiciousFiles }
    Invoke-Section -Title "BAM State User Settings" { Get-BAMStateUserSettings }
    Invoke-Section -Title "Prefetch Files" { Get-PrefetchFiles }
    Invoke-Section -Title "Suspicious Processes" { Get-SuspiciousProcesses }
    Invoke-Section -Title "Suspicious Network Connections" { Get-SuspiciousNetworkConnections }
    Invoke-Section -Title "Recent Programs" { Get-RecentPrograms }
    Invoke-Section -Title "Suspicious Scheduled Tasks" { Get-SuspiciousScheduledTasks }
    Invoke-Section -Title "Suspicious Drivers" { Get-SuspiciousDrivers }

    Write-Host "[>] Running DMA-focused checks..." -ForegroundColor Cyan
    Invoke-Section -Title "DMA Drivers/Services" { Find-DMADriversAndServices }
    Invoke-Section -Title "DMA Processes" { Find-DMAProcesses }
    Invoke-Section -Title "DMA Services" { Find-DMAServices }
    Invoke-Section -Title "DMA Devices" { Find-DMADevices }
    Invoke-Section -Title "DMA Firmware Tools" { Find-DMAFirmwareTools }
    Invoke-Section -Title "DMA Spoofed Devices" { Find-DMASpoofedDevices }

    Write-Host "[>] Generating summary and risk score..."
    $riskScore = 0
    $summaryLines = @()

    $cheatIndicators = @(
        '[!] Suspicious files found:',
        '[!] Suspicious processes detected:',
        '[*] Suspicious network connections',
        '[!] Suspicious scheduled tasks detected:',
        '[!] Suspicious drivers detected:'
    )
    foreach ($indicator in $cheatIndicators) {
        if ($global:LogEntries -join "`n" -match [regex]::Escape($indicator)) {
            $riskScore += 2
            $summaryLines += "- $indicator"
        }
    }
    

    if ($riskScore -ge 4) {
        $riskLevel = 'HIGH'
        $recommendation = 'Immediate investigation recommended. Multiple cheat indicators found.'
    } elseif ($riskScore -ge 2) {
        $riskLevel = 'MEDIUM'
        $recommendation = 'Potential risk detected. Review findings and monitor system.'
    } else {
        $riskLevel = 'LOW'
        $recommendation = 'No significant risks detected.'
    }
    $summarySection = @()
    $summarySection += "================== SUMMARY =================="
    $summarySection += "Risk Score: $riskScore ($riskLevel)"
    $summarySection += "Key Findings:"
    if ($summaryLines.Count -gt 0) {
        $summarySection += $summaryLines
    } else {
        $summarySection += "- No suspicious activity detected."
    }
    $summarySection += "Recommendation: $recommendation"
    $summarySection += "============================================"
    $global:LogEntries += $summarySection
    $global:Summary = $summarySection
    Write-Host ($summarySection -join "`n")

    $desktopPath = [System.Environment]::GetFolderPath('Desktop')

    $htmlFilePath = Write-UnifiedHtmlReport -OutputPath (Join-Path -Path $desktopPath -ChildPath "SystemCheckReport.html")

    try {
        Set-DiscordWebhook
        if ($global:DiscordWebhookUrl) {
            Write-Host "[>] Sending unified HTML report to Discord..."
            Send-DiscordLogFile -Files @($htmlFilePath)
        } else {
            Write-Host "[~] Skipping Discord upload (no webhook configured)."
        }
    } catch {
        Write-Host "[-] Error sending logs to Discord: $_"
    }
}

Invoke-SystemCheck

Write-Host ""
Write-Host "Press Enter to exit..."
Read-Host | Out-Null



